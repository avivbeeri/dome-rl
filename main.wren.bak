import "graphics" for Canvas, Color, ImageData
import "input" for Keyboard
import "./sprite" for Sprite, Enemy

class Animation {
  construct new() {
    _running = true
  }

  done() { _running = false }
  complete { !_running }
}

class BulletAnimation is Animation {
  construct new(source, target) {
    super()
    _t = 0
    _target = target
    _source = source
  }

  update() {
    _t = _t + 1/60
  }

  draw(dt) {
    _t = _t + dt
    var srcY = _source.y*16+24
    var targetY = _target.y*16+8
    // 1 square : 0.25 second
    // 2 squares:
    var y = srcY + (targetY - srcY) * _t
    Canvas.rectfill(_source.x*16+15, srcY, 2, targetY-srcY, Color.yellow)

    if (_t > 0.25) {
      System.print("animation done")
      done()
    }
  }
}

var Dir = {
  "left": { "x": -1, "y": 0 },
  "right": { "x": 1, "y": 0 },
  "up": { "x": 0, "y": -1 },
  "down": { "x": 0, "y": 1 }
}

class Game {

  static init() {
    __energy = 10
    __robot = Sprite.new("res/robot.png", 3, 6)
    __enemy = Enemy.new("res/enemy.png", 2, 1)
    __enemy.fireState = 1
    __enemy2 = Enemy.new("res/enemy.png", 1, 1)
    __key = null
    __tiles = ImageData.loadFromFile("res/tilemap.png")
    __previous = {
      "left": false,
      "right": false,
      "up": false,
      "down": false
    }
    __map = [
     0,0,0,2,0,0,0,
     0,0,0,0,0,0,0,
     0,0,0,0,0,0,0,
     0,1,0,1,0,1,0,
     0,0,0,0,0,0,0,
     0,0,0,0,0,0,0,
     0,0,0,0,0,0,0
    ]

    __enemies = [ __enemy, __enemy2 ]
    __animations = []
  }
  static draw(dt) {
    Canvas.cls()
    if (__energy <= 0) {
      Canvas.print("Game Over", 0, 0, Color.white)
    } else {
      Canvas.print("Energy: %(__energy)", 0, 0, Color.white)
    }

    // Draw map
    for (y in 0...7) {
      for (x in 0...7) {
        var index = y * 7 + x
        var tile = __map[index]
        __tiles.drawArea(16 * tile, 0, 16, 16, 8 + x * 16, 8 + y * 16)
      }
    }

    __enemies.each {|enemy| enemy.draw() }
    __animations = __animations.where {|animation| animation != null && !animation.complete}.toList
    __animations.each {|animation| animation.draw(dt) }
    __robot.draw()

  }
  static update() {
    var newTurn = false
    var previous = __previous
    if (__animations.count > 0) {
      __animations.each {|animation| animation.update() }
      return
    }
    for (key in Dir.keys) {
      var current = Keyboard.isKeyDown(key)
      if (current && !previous[key]) {
        var destX = __robot.x + Dir[key]["x"]
        var destY = __robot.y + Dir[key]["y"]

        if ((destX >= 0 && destX < 7) && (destY >= 0 && destY < 7)) {
          var tile = __map[destY * 7 + destX]

          var isSolid = (tile == 1)
            if (!isSolid) {
            __robot.x = destX
            __robot.y = destY
            __energy = __energy - 1
            newTurn = true
          }
        }
      }
      previous[key] = current
    }

    if (newTurn) {
      __enemies.each {|enemy|

        var hit = false
        if (enemy.x == __robot.x) {
          var dir = - (enemy.y - __robot.y) / (enemy.y - __robot.y).abs
          System.print(dir)
          var y = enemy.y
          var solid = false
          while (!solid && y != __robot.y) {
            y = y + dir
            var tile = __map[y * 7 + enemy.x]
            solid = (tile == 1)
          }
          hit = !solid
          if (hit) {
            __animations.add(enemy.fire(__robot))
          }
          System.print("Hit: %(hit)")
        }
      }
    }
  }


}
